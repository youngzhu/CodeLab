# Ch02 线程安全性
- 无状态（没有共享变量）的对象一定是线程安全的，如 StatelessFactorizer 类
- 当执行时间较长的计算或无法快速完成的操作时（如网络连接、文件读写等），一定不能持有锁

# Ch03 对象的共享
- 小建议：对于服务器应用程序，启动JVM时一定要指定 `-server` 命令行选项。Server模式的JVM比Client模式的进行了更多的优化

## volatile

> 加锁机制既可以确保可见性又可以确保原子性，而 `volatile` 变量只能确保可见性
>

当且仅当同时满足以下所有条件时才应该使用 volatile 变量：
1. 对变量的写入操作不依赖变量的当前值，或者能够确保只有单个线程更新变量的值
2. 该变量不会与其他状态变量一起纳入不变性条件中
3. 在访问变量时不需要加锁

## 不可变对象
不可变对象一定是线程安全的

满足以下条件时，对象才是不可变的：
- 对象创建以后其状态就不能修改
- 对象的所有域都是 `final` 类型
- 对象是正确创建的（没有this引用逸出）

# Ch05
## 5.5 同步工具类
### 5.5.1 闭锁（代码5-11）
闭锁，可以延迟线程的进度直到其到达终止状态。

应用：
- 确保某个计算在其需要的资源都被初始化后才继续执行
- 确保某个服务在其依赖的所有其他服务都已启动之后才启动
- 等待直到某个操作的所有参与者都就绪后在执行。例如斗地主，只有当四个玩家全部就绪时，闭锁将到达结束状态，这时才能开局

### 5.5.2 FutureTask（代码5-12）
FutureTask也可用做闭锁。

Future.get 的行为取决于任务的状态。如果任务已经完成，那么get会立即返回结果；否则get将等待直到任务进入完成状态，然后返回结果或者抛出异常。

### 5.5.3 信号量（5-14）
计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。也可以用来实现某种资源池，或者对容器施加边界。

Semaphore管理着一组虚拟的许可（permit），许可的数量可通过构造函数指定。在执行操作时首先获得许可（如果还有剩余的话），并在使用后释放许可。如果没有许可，acquire 将一直阻塞直到有可用的许可。

### 5.5.4 栅栏（5-15）
栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。

栅栏与闭锁的关键区别在于所有线程必须同时到达栅栏位置才能继续执行。闭锁用于等待事件；而栅栏用于等待其他线程。

栅栏用于实现一些协议，例如几个家庭成员在某个地方集合：所有人6:00在麦当劳碰头，到了之后要等其他人，之后再一起讨论下一步要做的事。 

CyclicBarrier 可以使一定数量的参与方反复地栅栏位置汇集，它在并行迭代算法中非常有用：这种算法通常讲一个问题拆分为一系列相互独立的子问题。当线程到达栅栏位置时将调用 await 方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都被释放，而栅栏将被重置以便下次使用。

在模拟程序中通常需要使用栅栏，例如某个步骤中的计算可以并行执行，但必须等到该步骤中所有计算都执行完毕才能进入下一个步骤。

例如，在n-body粒子模拟系统中，某个步骤都根据其他粒子的位置和属性来计算各个粒子的新位置。通过在每两次更新之间的等待栅栏，能够确保在第k步中的所有更新操作都已计算完毕，才进入第k+1步。