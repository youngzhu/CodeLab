# 排序

## Selection Sort 选择排序
基本思想：第 N 次遍历找出第 N 小的值  
第1次：比较第a[0]和a[i]的大小，如果 a[0]>a[j]，交换  
直到第 n-1 次  
时间复杂度：O(n^2)

## Bubble Sort 冒泡排序
基本思想：从右端开始，相邻的两个两两比较，非有序的则交换  
第一次遍历完，最小的在第一个  
时间复杂度：O(n^2)

## Insertion Sort 插入排序
基本思想：sublist，从局部扩展到整体。
把第一个元素看着是一个有序的，然后看第二个元素，将其插入正确的位置。  
时间复杂度：O(n^2)

Bubble VS Insertion
前者必须做N次的比较；后者可能会提前结束，比较次数 <= N

## Shell Sort 加强版的插入排序
基本思想：越是有序的列表，使用插入排序时效率越高。
所以挑选元素（间隔）先大致排序，间隔=1（相邻）时就完全是一个插入排序。  
复杂度：O(n)~O(n^2)

## Merge Sort 合并排序
基本思想：分割，合并，递归  
复杂度：O(NlogN)

## Quick Sort
基本思想：分割+递归。选择一个元素（可以是第一个），
将其放到正确的位置。左边都是比他小的，右边都是大的。
再用同样的方法对左右两个列表排序。  
复杂度：O(NlogN)

## 应用 —— 查找
排序后，用二分法查找，效率更高  
复杂度：O(logN)

## Heap Sort 堆排序
时间复杂度：O(NlogN)  
空间复杂度：O(1)